// Created by Jorge Puerto. All Rights Reserved.

#include "BAMorphTarget.h"
#include "ProfilingDebugging/ResourceSize.h"
#include "EngineUtils.h"
#include "Animation/MorphTarget.h"
#include "Engine/SkeletalMesh.h"
#include "HAL/LowLevelMemTracker.h"
#include "Rendering/SkeletalMeshModel.h"
#include "Rendering/SkeletalMeshLODModel.h"
#include "UObject/EditorObjectVersion.h"


/** compare based on base mesh source vertex indices */
struct FCompareMorphTargetDeltas2
{
	FORCEINLINE bool operator()(const FMorphTargetDelta& A, const FMorphTargetDelta& B) const
	{
		return ((int32)A.SourceIdx - (int32)B.SourceIdx) < 0 ? true : false;
	}
};

FMorphTargetDelta* UBAMorphTarget::GetMorphTargetDelta(int32 LODIndex, int32& OutNumDeltas)
{
	if (LODIndex < MorphLODModels.Num())
	{
		FMorphTargetLODModel& MorphModel = MorphLODModels[LODIndex];
		OutNumDeltas = MorphModel.Vertices.Num();
		return MorphModel.Vertices.GetData();
	}

	OutNumDeltas = 0;
	return NULL;
}

bool UBAMorphTarget::HasDataForLOD(int32 LODIndex)
{
	// If we have an entry for this LOD, and it has verts
	return (MorphLODModels.IsValidIndex(LODIndex) && MorphLODModels[LODIndex].Vertices.Num() > 0);
}

bool UBAMorphTarget::HasValidData() const
{
	for (const FMorphTargetLODModel& Model : MorphLODModels)
	{
		if (Model.Vertices.Num() > 0)
		{
			return true;
		}
	}

	return false;
}

#if WITH_EDITOR

void UBAMorphTarget::PopulateDeltas(const TArray<FMorphTargetDelta>& Deltas, const int32 LODIndex, const TArray<FSkelMeshSection>& Sections, const bool bCompareNormal, const bool bGeneratedByReductionSetting, const float PositionThreshold)
{
	// create the LOD entry if it doesn't already exist
	if (LODIndex >= MorphLODModels.Num())
	{
		MorphLODModels.AddDefaulted(LODIndex - MorphLODModels.Num() + 1);
	}

	// morph mesh data to modify
	FMorphTargetLODModel& MorphModel = MorphLODModels[LODIndex];
	// copy the wedge point indices
	// for now just keep every thing 

	// set the original number of vertices
	MorphModel.NumBaseMeshVerts = Deltas.Num();

	// empty morph mesh vertices first
	MorphModel.Vertices.Empty(Deltas.Num());

	// mark if generated by reduction setting, so that we can remove them later if we want to
	// we don't want to delete if it has been imported
	MorphModel.bGeneratedByEngine = bGeneratedByReductionSetting;

	// Still keep this (could remove in long term due to incoming data)
	for (const FMorphTargetDelta& Delta : Deltas)
	{
		if (Delta.PositionDelta.SizeSquared() > FMath::Square(PositionThreshold) ||
			(bCompareNormal && Delta.TangentZDelta.SizeSquared() > 0.01f))
		{
			MorphModel.Vertices.Add(Delta);
			for (int32 SectionIdx = 0; SectionIdx < Sections.Num(); ++SectionIdx)
			{
				if (MorphModel.SectionIndices.Contains(SectionIdx))
				{
					continue;
				}
				const uint32 BaseVertexBufferIndex = (uint32)(Sections[SectionIdx].GetVertexBufferIndex());
				const uint32 LastVertexBufferIndex = (uint32)(BaseVertexBufferIndex + Sections[SectionIdx].GetNumVertices());
				if (BaseVertexBufferIndex <= Delta.SourceIdx && Delta.SourceIdx < LastVertexBufferIndex)
				{
					MorphModel.SectionIndices.AddUnique(SectionIdx);
					break;
				}
			}
		}
	}

	// sort the array of vertices for this morph target based on the base mesh indices
	// that each vertex is associated with. This allows us to sequentially traverse the list
	// when applying the morph blends to each vertex.
	MorphModel.Vertices.Sort(FCompareMorphTargetDeltas2());

	// remove array slack
	MorphModel.Vertices.Shrink();
}

void UBAMorphTarget::RemoveEmptyMorphTargets()
{
	// do not remove LOD 0
	for (int32 CurIndex = MorphLODModels.Num() - 1; CurIndex > 0; --CurIndex)
	{
		//  if it's empty, no reason to keep
		if (MorphLODModels[CurIndex].Vertices.Num() == 0)
		{
			MorphLODModels.RemoveAt(CurIndex);
		}
		else
		{
			// we leave empty ones between. We can't remove between ones. 
			// Once we found valid one, just get out
			break;
		}
	}
}

#endif // WITH_EDITOR


//////////////////////////////////////////////////////////////////////////

void UBAMorphTarget::Serialize(FArchive& Ar)
{
	LLM_SCOPE(ELLMTag::Animation);

	Super::Serialize(Ar);
	Ar.UsingCustomVersion(FEditorObjectVersion::GUID);

}


void UBAMorphTarget::GetResourceSizeEx(FResourceSizeEx& CumulativeResourceSize)
{
	Super::GetResourceSizeEx(CumulativeResourceSize);

	for (const auto& LODModel : MorphLODModels)
	{
		CumulativeResourceSize.AddUnknownMemoryBytes(LODModel.Vertices.GetAllocatedSize() + sizeof(int32));
	}
}


void UBAMorphTarget::PostLoad()
{
	Super::PostLoad();

#if WITH_EDITOR
	if (GetLinkerCustomVersion(FEditorObjectVersion::GUID) < FEditorObjectVersion::AddedMorphTargetSectionIndices &&
		BaseSkelMesh)
	{
		const int32 MaxLOD = FMath::Min(BaseSkelMesh->GetImportedModel()->LODModels.Num(), MorphLODModels.Num());
		for (int32 LODIndex = 0; LODIndex < MaxLOD; ++LODIndex)
		{
			FMorphTargetLODModel& MorphLODModel = MorphLODModels[LODIndex];
			MorphLODModel.SectionIndices.Empty();
			const FSkeletalMeshLODModel& LODModel = BaseSkelMesh->GetImportedModel()->LODModels[LODIndex];
			TArray<int32> BaseIndexes;
			TArray<int32> LastIndexes;
			for (int32 SectionIdx = 0; SectionIdx < LODModel.Sections.Num(); ++SectionIdx)
			{
				const int32 BaseVertexBufferIndex = LODModel.Sections[SectionIdx].GetVertexBufferIndex();
				BaseIndexes.Add(BaseVertexBufferIndex);
				LastIndexes.Add(BaseVertexBufferIndex + LODModel.Sections[SectionIdx].GetNumVertices());
			}
			// brute force
			for (int32 VertIndex = 0; VertIndex < MorphLODModel.Vertices.Num() && MorphLODModel.SectionIndices.Num() < BaseIndexes.Num(); ++VertIndex)
			{
				int32 SourceVertexIdx = MorphLODModel.Vertices[VertIndex].SourceIdx;
				for (int32 SectionIdx = 0; SectionIdx < BaseIndexes.Num(); ++SectionIdx)
				{
					if (!MorphLODModel.SectionIndices.Contains(SectionIdx))
					{
						if (BaseIndexes[SectionIdx] <= SourceVertexIdx && SourceVertexIdx < LastIndexes[SectionIdx])
						{
							MorphLODModel.SectionIndices.AddUnique(SectionIdx);
							break;
						}
					}
				}
			}
		}
	}
#endif //#if WITH_EDITOR
}
